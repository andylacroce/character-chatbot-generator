/**
 * API endpoint for serving audio files generated by Google Text-to-Speech.
 * This file handles retrieval and streaming of audio content to the client.
 * @module audio-api
 */

import { NextApiRequest, NextApiResponse } from "next";
import fs from "fs";
import path from "path";
import { synthesizeSpeechToFile } from "../../src/utils/tts";
import { getReplyCache } from "../../src/utils/cache";

// Helper: Try to extract the original text from a sidecar file (if available)
function getOriginalTextForAudio(sanitizedFile: string): string | null {
  const txtFile = sanitizedFile.replace(/\.mp3$/, ".txt");
  const txtPathTmp = path.resolve("/tmp", txtFile);
  const txtPathPublic = path.resolve("public", txtFile);
  if (fs.existsSync(txtPathTmp)) {
    return fs.readFileSync(txtPathTmp, "utf8");
  }
  if (fs.existsSync(txtPathPublic)) {
    return fs.readFileSync(txtPathPublic, "utf8");
  }
  return null;
}

/**
 * API handler for serving audio files to the client.
 * This handler validates the requested file parameter, checks for its existence,
 * and streams the audio content back to the client with proper headers.
 *
 * @function
 * @param {NextApiRequest} req - The Next.js API request object containing the file parameter
 * @param {NextApiResponse} res - The Next.js API response object for streaming the audio
 * @returns {Promise<void>}
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  // Extract and validate the file parameter
  const { file } = req.query;

  if (!file || typeof file !== "string") {
    return res.status(400).json({ error: "File parameter is required" });
  }

  // Sanitize filename to prevent directory traversal attacks
  const sanitizedFile = path.basename(file);

  // Determine potential file paths (temporary directory or public directory)
  const audioFilePath = path.resolve("/tmp", sanitizedFile);
  const localFilePath = path.resolve("public", sanitizedFile);

  /**
   * Helper function to check if a file exists and return its normalized path
   * @param {string} filePath - Path to check
   * @returns {string} Normalized real path if exists, empty string otherwise
   */
  const checkFileExists = (filePath: string) =>
    fs.existsSync(filePath) ? fs.realpathSync(filePath) : "";

  // Check both potential locations for the file
  let normalizedAudioFilePath = checkFileExists(audioFilePath);
  let normalizedLocalFilePath = checkFileExists(localFilePath);

  // Retry file check a few times if not found (handles race conditions with file creation)
  for (let i = 0; i < 5; i++) {
    if (normalizedAudioFilePath || normalizedLocalFilePath) break;

    // Wait 1 second between retries
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Check again
    normalizedAudioFilePath = checkFileExists(audioFilePath);
    normalizedLocalFilePath = checkFileExists(localFilePath);
  }

  // If still not found, try to regenerate using TTS if possible
  if (!normalizedAudioFilePath && !normalizedLocalFilePath) {
    // Try to get the original text for this audio file
    let originalText = getOriginalTextForAudio(sanitizedFile);
    // Fallback: try cache if .txt is missing
    if (!originalText) {
      originalText = getReplyCache(sanitizedFile);
    }
    if (originalText) {
      try {
        await synthesizeSpeechToFile({
          text: `<speak><prosody pitch=\"-13st\" rate=\"80%\"> ${originalText} </prosody></speak>`,
          filePath: audioFilePath,
          ssml: true,
        });
        normalizedAudioFilePath = checkFileExists(audioFilePath);
      } catch (err) {
        return res.status(500).json({ error: "Failed to regenerate audio via TTS" });
      }
    }
  }

  // Verify file path is within allowed directories (security check)
  const allowedTmp = path.resolve("/tmp");
  const allowedPublic = path.resolve("public");
  if (
    (normalizedAudioFilePath && !normalizedAudioFilePath.startsWith(allowedTmp)) &&
    (normalizedLocalFilePath && !normalizedLocalFilePath.startsWith(allowedPublic))
  ) {
    return res.status(403).json({ error: "Access forbidden" });
  }

  // Use the first valid path found
  const filePath = normalizedAudioFilePath || normalizedLocalFilePath;

  // Final existence check
  if (!filePath || !fs.existsSync(filePath)) {
    return res.status(404).json({ error: "File not found" });
  }

  // Read file content and stream to client
  let audioContent;
  try {
    audioContent = fs.readFileSync(filePath);
  } catch (err) {
    return res.status(500).json({ error: "Error reading file" });
  }

  // Set appropriate content type for MP3 audio
  res.setHeader("Content-Type", "audio/mpeg");
  res.send(audioContent);
}
